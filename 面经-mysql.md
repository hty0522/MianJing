# mysql

### MySQL常用的存储引擎有什么？它们有什么区别？

- InnoDB
  InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。
- MyISAM
  MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。

![image-20220117144239281](面经-mysql.assets\image-20220117144239281.png)

### 数据库的三大范式

- 第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。
- 第二范式：确保表中的每列都和主键相关
- 第三范式：确保每列都和主键列直接相关而不是间接相关

### MySQL的数据类型有哪些

#### 整数

​		TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别占用8、16、24、32、64位存储空间。值得注意的是，INT(10)中的10只是表示显示字符的个数，并无实际意义。一般和UNSIGNED ZEROFILL配合使用才有实际意义，例如，数据类型INT(3)，属性为UNSIGNED ZEROFILL，如果插入的数据为3的话，实际存储的数据为003。

#### 浮点数

​		FLOAT、DOUBLE及DECIMAL为浮点数类型，DECIMAL是利用字符串进行处理的，能存储精确的小数。相比于FLOAT和DOUBLE，DECIMAL的效率更低些。FLOAT、DOUBLE及DECIMAL都可以指定列宽，例如FLOAT(5,2)表示一共5位，两位存储小数部分，三位存储整数部分。

![image-20220117145044333](面经-mysql.assets\image-20220117145044333.png)

#### 字符串

​		字符串常用的主要有CHAR和VARCHAR，VARCHAR主要用于存储可变长字符串，相比于定长的CHAR更节省空间。CHAR是定长的，根据定义的字符串长度分配空间。
​		**应用场景**：对于经常变更的数据使用CHAR更好，CHAR不容易产生碎片。对于非常短的列也是使用CHAR更好些，CHAR相比于VARCHAR在效率上更高些。一般避免使用TEXT/BLOB等类型，因为查询时会使用临时表，造成严重的性能开销。

![image-20220117145119455](面经-mysql.assets\image-20220117145119455.png)

#### 日期

​		比较常用的有year、time、date、datetime、timestamp等，datetime保存从1000年到9999年的时间，精度位秒，使用8字节的存储空间，与时区无关。timestamp和UNIX的时间戳相同，保存从1970年1月1日午夜到2038年的时间，精度到秒，使用四个字节的存储空间，并且与时区相关。
​		应用场景：尽量使用timestamp，相比于datetime它有着更高的空间效率。

![image-20220117145109054](面经-mysql.assets\image-20220117145109054.png)

### ---------------------------

### redo log & binlog

![image-20220124221200588](面经-mysql.assets\image-20220124221200588.png)

![image-20220117163938955](面经-mysql.assets\image-20220117163938955.png)



![image-20220117164026185](面经-mysql.assets\image-20220117164026185.png)

![image-20220117164047341](面经-mysql.assets\image-20220117164047341.png)

如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致

Crash recovery

​		binlog有记录，redolog状态commit：正常完成的事务，不需要恢复；
​		binlog有记录，redolog状态prepare：在binlog写完提交事务之前的crash，恢复操作：提交事务。（因为之前没有提交）
​		binlog无记录，redolog状态prepare：在binlog写完之前的crash，恢复操作：回滚事务（因为crash时并没有成功写入数据库

### undo log

### ---------------------------

### 隔离性与隔离级别

ACID（Atomicity、Consistency、Isolation、Durability，即**原子性、一致性、隔离性、持久性**），

![image-20220117191409006](面经-mysql.assets\image-20220117191409006.png)

![image-20220117191423973](面经-mysql.assets\image-20220117191423973.png)

![image-20220117191434179](面经-mysql.assets\image-20220117191434179.png)

### ---------------------------

### 索引

​		哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。哈希索引对于单行查询有明显的优势，局限见下一问题。

#### 什么是索引？　

​		百度百科的解释：索引是对数据库表的一列或者多列的值进行排序一种结构，使用索引可以快速访问数据表中的特定信息。

#### 索引的优缺点？

优点：

- 大大加快数据检索的速度。
- 将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的)
- 加速表与表之间的连接

缺点：

- 从空间角度考虑，建立索引需要占用物理空间
- 从时间角度 考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引。

#### 什么是前缀索引？

​		前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

​		使用场景：前缀的区分度比较高的情况下。

建立前缀索引的方式

```
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
```

​		这里面有个prefix_length参数很难确定，这个参数就是前缀长度的意思。通常可以使用以下方法进行确定，先计算全列的区分度

```
SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
```

​		然后在计算前缀长度为多少时和全列的区分度最相似。

```
SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
```

不断地调整prefix_length的值，直到和全列计算出区分度相近。

#### 什么是最左匹配原则？

​		最左匹配原则：从最左边为起点开始连续匹配，**遇到范围查询（<、>、between、like）会停止匹配。**

​		例如建立索引(a,b,c)，大家可以猜测以下几种情况是否用到了索引。

- 第一种

```java
select * from table_name where a = 1 and b = 2 and c = 3 
select * from table_name where b = 2 and a = 1 and c = 3
```

上面两次查询过程中所有值都用到了索引，where后面字段调换不会影响查询结果，因为MySQL中的优化器会自动优化查询顺序。

- 第二种

```java
select * from table_name where a = 1
select * from table_name where a = 1 and b = 2  
select * from table_name where a = 1 and b = 2 and c = 3
```

答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。

- 第三种

```java
select * from table_name where  b = 1 
select * from table_name where  b = 1 and c = 2 
```

答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的

- 第四种

```java
select * from table_name where a = 1 and c = 2 
```

这个查询语句只有a列用到了索引，c列没有用到索引，因为中间跳过了b列，不是从最左开始连续匹配的。

- 第五种

```java
select * from table_name where  a = 1 and b < 3 and c < 1
```

这个查询中只有a列和b列使用到了索引，而c列没有使用索引，因为根据最左匹配查询原则，遇到范围查询会停止。

- 第六种

```java
select * from table_name where a like 'ab%'; 
select * from table_name where  a like '%ab'
select * from table_name where  a like '%ab%'
```

- 对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描。

#### 为什么mysql索引结构默认B+树

​		索引是一种便于数据查询的数据结构，而树形结构普遍有O（logN）的查询时间复杂度，而且插入删除数据的性能也比较平均，相比之下哈希数据结构不好做范围查询，而数组结构虽然查询快，但是删除增加效率太低，因此优选树形结构。

制约查询速度的瓶颈在于磁盘IO的次数，B+树同其他树形结构相比，在非叶子节点中保存的指针数最多，因此同样数据量下树高低，IO操作少，查询性能高。

​		在计算机中，磁盘存储数据最小单元是扇区，**一个扇区的大小是512字节，**而文件系统（例如XFS/EXT4）的最小单元是块，**一个块的大小是4k**，而对于InnoDB存储引擎也有自己的最小储存单元，页（Page），**一个页的大小是16K**。

里我们先假设 B+ 树高为 2，即存在一个根节点和若干个[叶子节点](https://www.zhihu.com/search?q=叶子节点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"139002393"})，那么这棵 B+ 树的存放总记录数为：根节点指针数*单个叶子节点记录行数。

上文我们已经说明单个叶子节点(页)中的记录数=16K/1K=16。(这里假设一行记录的数据大小为 1K，实际上现在很多互联网业务数据记录大小通常就是 1K 左右)。

那么现在我们需要计算出非叶子节点能存放多少指针?其实这也很好算，我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。

我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。

那么可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。

根据同样的原理我们可以算出一个高度为 3 的 B+ 树可以存放：1170*1170*16=21902400 条这样的记录。

### ---------------------------

### 聚簇索引 & 非聚簇索引

#### 聚簇索引和非聚簇索引的区别

​		主键索引[叶子节点](https://www.zhihu.com/search?q=叶子节点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"143784319"})的值存储的就是MySQL的数据行，普通索引的叶子节点的值存储的是主键值。

​		如果找到了索引就找到了需要的数据，那这个索引就是聚簇索引，所以通过主键查询一定是聚簇索引，如果我们我们找到了索引但没找到数据，那就要根据索引上的值（主键）再次回表查询。

![image-20220117210655654](面经-mysql.assets\image-20220117210655654.png)



用语言描述一下，是这样的：

1. 先找到根节点所在磁盘块，读入内存。（第1次磁盘I/O操作）
2. 在内存中判断id=3所在区间(0,8)，找到该区间对应的指针1（第1次内存查找）
3. 根据指针1记录的磁盘地址，找到磁盘块2并读入内存（第2次磁盘I/O操作）
4. 在内存中判断id=3所在区间(0,4)，找到该区间对应的指针2（第2次内存查找）
5. 根据指针2记录的磁盘地址，找到磁盘块4并读入内存（第3次磁盘I/O操作）
6. 在内存中查找到id=2对应的数据行记录（第3次内存查找）

​		我们知道，磁盘I/O相对于内存运算（尤其内存中的主键是有序排列的，利用二分查找等算法效率非常高）耗时高得多，因此在数据库查询中，**减少磁盘访问时数据库的性能优化的主要手段。**

而分析上面过程，发现整个查询只需要3次磁盘I/O操作（其实`InnoDB`引擎是将根节点常驻内存的，第1次磁盘I/O操作并不存在）和3次内存查找操作。相对于不使用索引的遍历式查找，大大减少了对磁盘的访问，因此查找效率大幅提高。但是，因为索引树要与表中数据保持一致，因此当表发生数据增删改时，索引树也要相应修改，导致写数据比没有索引时开销大一些。

#### 非聚簇索引

![image-20220117212539964](面经-mysql.assets\image-20220117212539964.png)

![image-20220117212553603](面经-mysql.assets\image-20220117212553603.png)

![image-20220117212600376](面经-mysql.assets\image-20220117212600376.png)

#### 联合索引

![image-20220117212707634](面经-mysql.assets\image-20220117212707634.png)

### ---------------------------

### 事务　

#### 什么是数据库的事务？

​		[百度](https://www.zhihu.com/jump/super-jump/word?word=百度)百科的解释：数据库事务( **transaction**)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

#### 事务的四大特性是什么？

- 原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。 
- 一致性：一致性指事务在执行前后状态是一致的。 

​		**一致性是数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致。这种一致性是一种需要管理员去定义的规则。管理员如何指定规则，数据库就严格按照这种规则去处理数据。**比如我们规定转账前后总金额一定的，那么是事务完成后，数据库中总金额不变就是保证了一致性

- 隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。 
- 持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。 

#### 如何保证四大特性？

​		MySQL的存储引擎InnoDB使用重做日志（redo log）保证一致性与持久性，回滚日志（undo log）保证原子性，使用各种锁来保证隔离性。

#### 数据库的并发一致性问题

当多个事务并发执行时，可能会出现以下问题：

- 脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。 

  - 隔离级别为 = 未提交读时会出现脏读

  - 在select加锁的情况下，不管什么级别都不会脏读

- 不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。 

- 幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。 

- 丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。 

不可重复度和幻读看起来比较像，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被更新了。在幻读中，发现数据不一致主要是数据增多或者减少了。

#### 数据库的隔离级别有哪些？

- 未提交读：一个事务在提交前，它的修改对其他事务也是可见的。 
- 提交读：一个事务提交之后，它的修改才能被其他事务看到。 **行锁**
- 可重复读：在同一个事务中多次读取到的数据是一致的。 （默认隔离级别） **行锁**
- [串行化](https://www.zhihu.com/search?q=串行化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"2207943559"})：需要加锁实现，会强制事务串行执行。 

数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。

![image-20220118222754065](面经-mysql.assets\image-20220118222754065.png)

### ---------------------------

### 隔离级别如何实现，如何保证并发安全

​		依靠锁机制和多版本并发控制来实现。**提交读和可重复读**可以通过MVCC实现，**串行化可以通过锁机制**实现。

​		通过设置不同的隔离级别，并依靠锁机制和MVCC(多版本并发控制)实现的。

#### 什么是MVCC？

​		MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性能。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，**只有写写之间相互阻塞**，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。

在了解MVCC时应该先了解当前读和快照读。

- 当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修该当前记录，所以会对读取的记录加锁。 
- 快照读：**不加锁读取操作即为快照读**，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。 

​		可以看到MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。

MVCC的实现原理：

- 版本号
   系统版本号：是一个自增的ID，每开启一个事务，系统版本号都会递增。
   事务版本号：**事务版本号就是事务开始时的系统版本号**，可以通过事务版本号的大小判断事务的时间顺序。
- 行记录隐藏的列
   **DB_ROW_ID**：所需空间6byte，隐含的自增ID，用来生成聚簇索引，如果数据表没有指定聚簇索引，InnoDB会利用这个隐藏ID创建聚簇索引。
   **DB_TRX_ID**：所需空间6byte，最近修改的事务ID，记录创建这条记录或最后一次修改这条记录的事务ID。***删除视为更新，将其标记为已删除***
   **DB_ROLL_PTR**：所需空间7byte，回滚指针，指向这条记录的上一个版本。
   它们大致长这样，省略了具体字段的值。

![image-20220118223132124](面经-mysql.assets\image-20220118223132124.png)

- undo日志

  ​		MVCC做使用到的快照会存储在Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照连接起来。它们大致长这样。

![image-20220118223411871](面经-mysql.assets\image-20220118223411871.png)

![image-20220118223534767](面经-mysql.assets\image-20220118223534767.png)

![image-20220118223549000](面经-mysql.assets\image-20220118223549000.png)

​		事务对同一记录的修改，记录的各个会在Undo日志中连接成一个[线性表](https://www.zhihu.com/search?q=线性表&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2207943559})，在表头的就是最新的旧纪录。

在重复读的隔离级别下，InnoDB的工作流程：

- SELECT
   作为查询的结果要满足两个条件：

1. 当前事务所要查询的数据行快照的创建版本号必须小于当前事务的版本号，这样做的目的是保证当前事务读取的数据行的快照要么是在当前事务开始前就已经存在的，要么就是当前事务自身插入或者修改过的。 
2. 当前事务所要读取的数据行快照的删除版本号必须是大于当前事务的版本号，如果是小于等于的话，表示该数据行快照已经被删除，不能读取。 

- INSERT
   将当前系统版本号作为数据行快照的创建版本号。
   
- DELETE
   将当前系统版本号作为数据行快照的删除版本号。
   
- UPDATE
   保存当前系统版本号为更新前的数据行快照创建行版本号，并保存当前系统版本号为更新后的数据行快照的删除版本号，其实就是，先删除在插入即为更新。

总结一下，MVCC的作用就是在避免加锁的情况下最大限度解决读写并发冲突的问题，它可以实现提交读和可重复度两个隔离级。

### 可重复读如何实现的

通过一致性视图和多版本并发控制（MVCC）实现。

​		**MVCC就是一种乐观锁的实现方式，而且是一种很常用的[乐观锁](https://www.zhihu.com/search?q=乐观锁&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1626229650"})实现方式。**

​		所谓多版本，就是一行记录在数据库中存储了多个版本，每个版本以事务ID作为版本号。InnoDB 里面每个事务有一个唯一的事务 ID，是在事务开始的时候向InnoDB的事务系统申请的，并且按照申请顺序严格递增的。假如一行记录被多个事务更新，那么，就会产生多个版本的记录。

以某一行数据作为例子：

![img](https://pic2.zhimg.com/v2-ed79d19e7d2729ebe40ed838a9e4619b_b.jpg)![img](https://pic2.zhimg.com/80/v2-ed79d19e7d2729ebe40ed838a9e4619b_720w.jpg)



经过两次事务的操作，value从22变成了19，同时，保留了三个事务id，15、25、30。

在每个记录多版本的基础上，需要利用“[一致性视图](https://www.zhihu.com/search?q=一致性视图&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1626229650"})”，来做版本的可见性判断。

这里，我们要区分MySQL里面的两个”视图”概念：

- 一个是view，通过语法create view … 实现，主要创建一个虚拟表，用来执行查询语句。
- 一个是InnoDB用来实现mvcc的一致性视图（consistent read view），纯逻辑概念，没有物理结构，定义了在事务期间，你能看到哪些版本的数据。

我们全文提到的“视图”都是第二种，主要是支持InnoDB在“读已提交”和“可重复读”级别的并发访问问题。

- “读未提及”级别下，没有一致性视图
- “读已提交”级别下，会在 **每个SQL开始执行的时候** 创建一致性视图
- “可重复读”级别下，会在 **每个事务开始的时候** 创建一致性视图
- “[串行化](https://www.zhihu.com/search?q=串行化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1626229650"})”级别下，直接通过加锁避免并发问题

下面，我们简单介绍一下创建一致性视图的逻辑。

以“可重复读”级别为例。

- 当一个事务开启的时候，会向系统申请一个新事务id
- 此时，可能还有多个正在进行的其他事务没有提交，因此在瞬时时刻，是有多个活跃的未提交事务id
- 将这些未提交的事务id组成一个数组，数组里面最小的事务id记录为低水位，当前系统创建过的事务id的最大值+1记录为高水位
- 这个数组array 和 高水位，就组成了“一致性视图”。

有了一致性视图后，我们就可以判断一行数据的多版本可见性了，***无论是“读已提交”还是“可重复读”级别，可见性判断规则是一样的，区别在于创建快照（一致性视图）的时间！！！***。

在当前事务中，读取其他某一行的记录，对其中的版本号的可见性判断有五种情况（建议自己跟着捋一捋，挺重要的）：

- 如果版本号小于“低水位”，说明事务已经提交，那肯定 可见；
- 如果版本号大于“高水位”，说明这行数据的这个事务id版本是在快照后产生的，那肯定 不可见；
- 如果版本号在事务数组array中，说明这个事务还没提交，所以 不可见；
- 如果版本号不在事务数组array中，且低于高水位，说明这个事务已经提交，所以 可见；
- 当然，无论什么时候，自己的[事务id](https://www.zhihu.com/search?q=事务id&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1626229650"})中的任何变化，都是可见的

可以看看下面这个例子，更容易理解。

> 系统创建过的事务id：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
> 事务A启动，拍个快照
> 此时未提交的事务id有：7，8，9
> 一致性视图：数组array[7,8,9] + 高水位16（15+1）

对于任意一行数据的可见性判断如下：

- 小于7的，可见
- 大于16的，说明是快照后产生的，不可见
- 10-15，不在数组array中，说明已经提交了，可见
- 7，8，9在array中，说明未提交，不可见

两个重要结论：

- **InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**
- **MVCC的实现，就是根据当前事务的事务id为依据创建“一致性视图”，利用一致性视图来判断数据版本的可见性。**

### -------------------------

### 数据库的锁　＊＊＊

#### 什么是数据库的锁？

​		当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。

#### 数据库的锁与隔离级别的关系？

![image-20220119124520515](面经-mysql.assets\image-20220119124520515.png)

#### 数据库锁的类型有哪些？

​		按照锁的粒度可以将MySQL锁分为三种：

![image-20220119124732610](面经-mysql.assets\image-20220119124732610.png)

MyISAM默认采用表级锁，InnoDB默认采用行级锁。

从锁的类别上区别可以分为共享锁和排他锁

- 共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。 
- 排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。

#### 存储引擎Innodb和Myisam的区别以及使用场景

​		myisam不支持事务，myisam是表级锁，myisam适合做读密集的；而Innodb适合读写密集的高并发的操作。

#### MySQL中InnoDB引擎的行锁模式及其是如何实现的？

​		1.**按照锁的粒度可以将数据库的锁主要分为行锁和表锁两类**

​		2.**表锁会对当前操作的整张表进行加锁，加锁快，不死锁，但并发能力比较低。行锁会对当前操作的行进行加锁，行锁能大大增加数据库的并发能力，但加锁的开销也最大，会出现死锁的情况。**

​		3.**意向锁是一种表锁，InnoDB支持多粒度锁，它允许行级锁和表级锁共存，当某一事物想对某个表加写锁时，对表的每一行都进行检测是非常低效的，而通过意向锁，只需检查是否有其他事务给这个表加了读、写、意向读、意向写锁即可**

**行锁模式**

​		在存在行锁和表锁的情况下，一个事务想对某个表加X锁时，需要先检查是否有其他事务对这个表加了锁或对这个表的某一行加了锁，对表的每一行都进行检测一次这是非常低效率的，为了解决这种问题，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，两种意向锁都是表锁。

- **意向共享锁--读锁**：简称IS锁，一个事务打算给数据行加共享锁前必须先获得该表的IS锁。 
- **意向排他锁--写锁**：简称IX锁，一个事务打算给数据行加排他锁前必须先获得该表的IX锁。 

有了意向锁，一个事务想对某个表加X锁，只需要检查是否有其他事务对这个表加了X/IX/S/IS锁即可。

锁的兼容性如下：

![image-20220119125600354](面经-mysql.assets\image-20220119125600354.png)

行锁实现方式：INnoDB的行锁是通过给索引上的索引项加锁实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录进行加锁。

InnoDB行锁主要分三种情况：

- Record lock：对索引项加锁 
- Grap lock：对索引之间的“间隙”、第一条记录前的“间隙”或最后一条后的间隙加锁。 
- Next-key lock：前两种放入组合，对记录及前面的间隙加锁。 

InnoDB行锁的特性：如果不通过索引条件检索数据，那么InnoDB将对表中所有记录加锁，实际产生的效果和表锁是一样的。

MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。

#### 什么是数据库的[乐观锁](https://www.zhihu.com/search?q=乐观锁&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2207943559})和悲观锁，如何实现？

​		**乐观锁**：系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。

乐观锁实现方式：一般通过版本号和CAS算法实现。

​		**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。

悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for updata。

#### 什么是死锁？如何避免？

​		死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在MySQL中，MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。

如何避免MySQL发生死锁或锁冲突：

- 如果不同的程序并发存取多个表，尽量以相同的顺序访问表。
- 在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。
- 在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。
- 尽量使用较低的隔离级别
- 尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会
- 合理选择事务的大小，**小事务发生锁冲突的概率更低**
- 尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。
- 不要申请超过实际需要的锁级别，**查询时尽量不要显示加锁**
- 对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。

### ---------------------------

### SQL语句基础知识

#### QL语句主要分为哪几类　

- **数据定义语言DDL**（Data Definition Language）：主要有CREATE，DROP，ALTER等对逻辑结构有操作的，包括表结构、视图和索引。 
- **数据库查询语言DQL**（Data Query Language）：主要以SELECT为主 
- **数据操纵语言DML**（Data Manipulation Language）：主要包括INSERT，UPDATE，DELETE 
- **数据控制功能DCL**（Data Control Language）：主要是权限控制能操作，包括GRANT，REVOKE，COMMIT，ROLLBACK等。 

#### SQL约束有哪些？

- [主键约束]()：主键为在表中存在一列或者多列的组合，能唯一标识表中的每一行。一个表只有一个主键，并且主键约束的列不能为空。 
- [外键约束]()：外键约束是指用于在两个表之间建立关系，需要指定**引用主表的哪一列**。**只有主表的主键可以被从表用作外键**，被约束的从表的列可以不是主键，所以创建外键约束需要先定义主表的主键，然后定义从表的外键。 
- [唯一约束]()：确保表中的一列数据没有相同的值，一个表可以定义多个唯一约束。 
- [默认约束]()：在插入新数据时，如果该行没有指定数据，系统将默认值赋给该行，如果没有设置没默认值，则为NULL。 
- [Check约束]()：Check会通过逻辑表达式来判断数据的有效性，用来限制输入一列或者多列的值的范围。在列更新数据时，输入的内容必须满足Check约束的条件。

#### 什么是子查询？

*子查询：把一个查询的结果在另一个查询中使用*

子查询可以分为以下几类：

- 标量子查询：指子查询返回的是一个值，可以使用 =,>,<,>=,<=,<>等操作符对子查询标量结果进行比较，一般子查询会放在比较式的右侧。

```mysql
SELECT * FROM user WHERE age = (SELECT max(age) from user)  //查询年纪最大的人
```

- 列子查询：指子查询的结果是n行一列，一般应用于对表的某个字段进行查询返回。可以使用IN、ANY、SOME和ALL等操作符，不能直接使用

```java
SELECT num1 FROM table1 WHERE num1 > ANY (SELECT num2 FROM table2)
```

- 行子查询：指子查询返回的结果一行n列

```java
SELECT * FROM user WHERE (age,sex) = (SELECT age,sex FROM user WHERE name="zhangsan")
```

- 表子查询：指子查询是n行n列的一个数据表

```mysql
SELECT * FROM student WHERE (name,age,sex) IN (SELECT name,age,sex FROM class1) //在学生
```

#### MySQL的几种连接查询

![image-20220119162848075](面经-mysql.assets\image-20220119162848075.png)

![image-20220119162855547](面经-mysql.assets\image-20220119162855547.png)

![image-20220119162912013](面经-mysql.assets\image-20220119162912013.png)

![image-20220119162922784](面经-mysql.assets\image-20220119162922784.png)

#### mysql中in和exists的区别？

in和exists一般用于子查询。

- 使用exists时会先进行外表查询，将查询到的每行数据带入到内表查询中看是否满足条件；使用in一般会先进行内表查询获取结果集，然后对外表查询匹配结果集，返回数据。 
- in在内表查询或者外表查询过程中都会用到索引。 
- exists仅在内表查询时会用到索引 
- **一般来说，当子查询的结果集比较大，外表较小使用exist效率更高；当子查询寻得结果集较小，外表较大时，使用in效率更高。** 
- 对于not in和not exists，not exists效率比not in的效率高，与子查询的结果集无关，因为not in对于内外表都进行了全表扫描，没有使用到索引。not exists的子查询中可以用到表上的索引。

#### varchar和char的区别？　

- varchar表示变长，char表示长度固定。当所插入的字符超过他们的长度时，在严格模式下，会拒绝插入并提示错误信息，在一般模式下，会截取后插入。如char(5)，无论插入的字符长度是多少，长度都是5，插入字符长度小于5，则用空格补充。对于varchar(5)，如果插入的字符长度小于5，则存储的字符长度就是插入字符的长度，不会填充。 
- 存储容量不同，对于char来说，最多能存放的字符个数为255。对于varchar，最多能存放的字符个数是65532。 
- 存储速度不同，char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。

#### drop、delete和truncate的区别？

![image-20220119204012096](面经-mysql.assets\image-20220119204012096.png)

#### UNION和UNION ALL的区别？

union和union all的作用都是将两个结果集合并到一起。

- union会对结果去重并排序，union all直接直接返回合并后的结果，不去重也不进行排序。
- union all的性能比union性能好。

### ---------------------------

### 什么是临时表

MySQL在执行SQL语句的时候会临时创建一些存储中间结果集的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。

临时表主要分为内存临时表和磁盘临时表两种。内存临时表使用的是MEMORY存储引擎，磁盘临时表使用的是MyISAM存储引擎。

一般在以下几种情况中会使用到临时表：

- FROM中的子查询 
- DISTINCT查询并加上ORDER BY 
- ORDER BY和GROUP BY的子句不一样时会产生临时表 
- 使用UNION查询会产生临时表

#### 大表数据查询如何进行优化？

- 索引优化
- SQL语句优化
- 水平拆分
- 垂直拆分
- 建立中间表
- 使用缓存技术
- 固定长度的表访问起来更快
- 越小的列访问越快

#### 了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？　＊＊＊

​		慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。

**相关参数：**

- slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。 
- slow_query_log_file：MySQL数据库慢查询日志存储路径。 
- long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。 
- log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。 
- log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。 

**如何对慢查询进行优化？**

- 分析语句的执行计划，查看SQL语句的索引是否命中 
- 优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。 
- 优化LIMIT分页

### ---------------------------

### 主键一般用自增ID还是UUID？　

使用自增ID的好处：

- 字段长度较uuid会小很多。 
- 数据库自动编号，按顺序存放，利于检索 
- 无需担心主键重复问题 

使用自增ID的缺点：

- 因为是自增，在某些业务场景下，容易被其他人查到业务量。 
- 发生数据迁移时，或者表合并时会非常麻烦 
- 在高并发的场景下，竞争自增锁会降低数据库的吞吐能力 

UUID：通用唯一标识码，UUID是基于当前时间、计数器和硬件标识等数据计算生成的。

使用UUID的优点：

- 唯一标识，不会考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。 
- 可以在应用层生成，提高数据库的吞吐能力。 
- 无需担心业务量泄露的问题。 

使用UUID的缺点：

- 因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。 
- UUID占用空间较大，建立的索引越多，造成的影响越大。 
- UUID之间比较大小较自增ID慢不少，影响查询速度。 

​		最后说下结论，一般情况MySQL推荐使用自增ID。因为在MySQL的InnoDB存储引擎中，主键索引是一种聚簇索引，主键索引的B+树的叶子节点按照顺序存储了主键值及数据，如果主键索引是自增ID，只需要按顺序往后排列即可，如果是UUID，ID是随机生成的，在数据插入时会造成大量的数据移动，产生大量的内存碎片，造成插入性能的下降。

### ---------------------------

### 如何优化查询过程中的数据访问？

**从减少数据访问方面考虑：**

- 正确使用索引，尽量做到索引覆盖 
- 优化SQL执行计划 

**从返回更少的数据方面考虑：**

- 数据分页处理 
- 只返回需要的字段 

**从减少服务器CPU开销方面考虑：**

- 合理使用排序 
- 减少比较的操作 
- 复杂运算在[客户端](https://www.zhihu.com/search?q=客户端&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2207943559})处理 

**从增加资源方面考虑**：

- 客户端多进程并行访问 
- 数据库并行处理

#### SQL语句执行的很慢原因是什么？

- 如果SQL语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是redo log日志写满了，要将redo log中的数据同步到磁盘中去。 
- 如果SQL语句一直都很慢，可能是字段上没有索引或者字段有索引但是没用上索引。

#### SQL语句的执行顺序?

```java
SELECT DISTINCT     select_list FROM     left_table LEFT JOIN     right_table ON join_condition WHERE     where_condition GROUP BY     group_by_list HAVING     having_condition ORDER BY     order_by_condition
```

执行顺序如下：

![img](https://pica.zhimg.com/50/v2-cd3e5f51f44891aa78ff0da38ac52d7e_720w.jpg?source=1940ef5c)

- FROM：对SQL语句执行查询时，首先对关键字两边的表以笛卡尔积的形式执行连接，并产生一个虚表V1。虚表就是视图，数据会来自多张表的执行结果。
- ON：对FROM连接的结果进行ON过滤,并创建虚表V2
- JOIN：将ON过滤后的左表添加进来，并创建新的虚拟表V3
- WHERE：对虚拟表V3进行WHERE筛选，创建虚拟表V4
- GROUP BY：对V4中的记录进行分组操作，创建虚拟表V5
- HAVING：对V5进行过滤，创建虚拟表V6
- SELECT：将V6中的结果按照SELECT进行筛选，创建虚拟表V7
- DISTINCT：对V7表中的结果进行去重操作，创建虚拟表V8，如果使用了GROUP BY子句则无需使用DISTINCT，因为分组的时候是将列中唯一的值分成一组，并且每组只返回一行记录，所以所有的记录都h是不同的。
- ORDER BY：对V8表中的结果进行排序。

### ---------------------------

### 为什么MySQL要读写分离

读写分离主要依赖于主从复制，主从复制为读写分离服务。

读写分离的优势：

- 主服务器负责写，从服务器负责读，缓解了锁的竞争
- 从服务器可以使用MyISAM，提升查询性能及节约系统开销
- 增加冗余，提高可用性

![preview](https://pic1.zhimg.com/v2-e8dcc0d09e97587919bf928104167138_r.jpg)

- 如果读写都在同一个数据库服务器操作，业务系统性能会降低，为提升业务性能，可以通过主从复制（读写分离）来减轻主数据库的负载

- 如果主数据库宕机，可快速将业务切换到从数据库上，可避免数据丢失；从库宕机还有其他从库

  ![image-20220121103642071](面经-mysql.assets\image-20220121103642071.png)

**第一步：**master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。

**第二步：**salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。

**第三步：**SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致

1. **「同步策略」**：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。
2. **「半同步策略」**：Master至少会等待一个Slave回应后提交。
3. **「异步策略」**：Master不用等待Slave回应就可以提交。
4. **「延迟策略」**：Slave要落后于Master指定的时间。

### ---------------------------

### explain命令

​		我们很多时候编写完一条[SQL语句](https://www.zhihu.com/search?q=SQL语句&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"51771446"})，往往想知道这条SQL语句执行是否高效。或者说，我们建立好的索引在这条SQL语句中是否使用到了，就可以使用`explain`命令来分析一下！

​		id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra