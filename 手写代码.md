### 生产者消费者

1. 关闭一个未初始化(nil) 的 channel 会产生 panic
2. 重复关闭同一个 channel 会产生 panic
3. 向一个已关闭的 channel 中发送消息会产生 panic
4. 从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已读出，则会读到类型的零值。从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 的 ok-idiom，可以用它来判断 channel 是否关闭
5. 关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息

```go
package main

import (
	"fmt"
	"math/rand"
	"strconv"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	producernum := 3
	consumer := 3
	maxmum :=100
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(consumer)

	dataCh := make(chan int, 100)
	stopCh := make(chan struct{})

	toStop := make(chan string,1)
	var stoppedBy string
	go func() {
		stoppedBy = <- toStop
		close(stopCh)
	}()
	for i := 0; i<producernum;i++{
		go func(i string) {
			for{
				value := rand.Intn(maxmum)
				if value == 0{
					select {
					case toStop <- "sender" + i:
					default:
					}
				}
				select {
				case <-stopCh:
					return
				case dataCh <-value:
				}

			}

		}(strconv.Itoa(i))
	}

	for i := 0; i<consumer; i++{
		go func(i string) {
			defer wgReceivers.Done()

			for{
				select {
				case <-stopCh:
					return
				case value := <-dataCh:
					if value == maxmum-1 {
						select {
						case toStop <- "receiver" + i:
						default:

						}
					}
					fmt.Println(value)
				}
			}

		}(strconv.Itoa(i))
	}

	wgReceivers.Wait()
	fmt.Println("stopped by", stoppedBy)
}

```

无缓冲通道channel必须在接受方与发送方同时准备好时，通道才能正常传递数据，否则双方只有一方在线都会阻塞。

缓冲通道当缓冲区满时，发送数据会阻塞，当缓冲区空时，接受数据会阻塞。发送方与接收方不需要同时做好准备。		



