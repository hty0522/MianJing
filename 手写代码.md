### 生产者消费者

1. 关闭一个未初始化(nil) 的 channel 会产生 panic
2. 重复关闭同一个 channel 会产生 panic
3. 向一个已关闭的 channel 中发送消息会产生 panic
4. 从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已读出，则会读到类型的零值。从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 的 ok-idiom，可以用它来判断 channel 是否关闭
5. 关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息

```go
package main

import (
	"fmt"
	"math/rand"
	"strconv"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	producernum := 3
	consumer := 3
	maxmum :=100
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(consumer)

	dataCh := make(chan int, 100)
	stopCh := make(chan struct{})

	toStop := make(chan string,1)
	var stoppedBy string
	go func() {
		stoppedBy = <- toStop
		close(stopCh)
	}()
	for i := 0; i<producernum;i++{
		go func(i string) {
			for{
				value := rand.Intn(maxmum)
				if value == 0{
					select {
					case toStop <- "sender" + i:
					default:
					}
				}
				select {
				case <-stopCh:
					return
				case dataCh <-value:
				}

			}

		}(strconv.Itoa(i))
	}

	for i := 0; i<consumer; i++{
		go func(i string) {
			defer wgReceivers.Done()

			for{
				select {
				case <-stopCh:
					return
				case value := <-dataCh:
					if value == maxmum-1 {
						select {
						case toStop <- "receiver" + i:
						default:

						}
					}
					fmt.Println(value)
				}
			}

		}(strconv.Itoa(i))
	}

	wgReceivers.Wait()
	fmt.Println("stopped by", stoppedBy)
}

```

无缓冲通道channel必须在接受方与发送方同时准备好时，通道才能正常传递数据，否则双方只有一方在线都会阻塞。

缓冲通道当缓冲区满时，发送数据会阻塞，当缓冲区空时，接受数据会阻塞。发送方与接收方不需要同时做好准备。		

### -----------------------------

交替打印ABC

```go
package main

import (
	"fmt"
	"time"
)

var chanA chan struct{}
var chanB chan struct{}
var chanC chan struct{}
func main() {
	chanA = make(chan struct{})
	chanB = make(chan struct{})
	chanC = make(chan struct{})

	go sendA()
	go sendB()
	go sendC()
	chanA <- struct{}{}
	time.Sleep(time.Second)
}

func sendA(){
	for{
		select {
		case <- chanA :
			fmt.Println("A")
			time.Sleep(time.Millisecond*100)
			chanB <- struct{}{}
		default:
		}
	}
}

func sendB(){
	for{
		select {
		case <- chanB :
			fmt.Println("B")
			time.Sleep(time.Millisecond*100)
			chanC <- struct{}{}
		default:
		}
	}
}

func sendC(){
	for{
		select {
		case <- chanC :
			fmt.Println("C")
			time.Sleep(time.Millisecond*100)
			chanA <- struct{}{}
		default:
		}
	}
}

```

### -----------------------------

go 实现协程池

```go
package main

import (
	"errors"
	"fmt"
	"time"
)

type Task struct {
	Handler func(v... interface{})
	Params  []interface{}
}

type Pool struct {
	capacity       uint64
	runningWorkers uint64
	state          int64
	taskC          chan *Task
	closeC         chan bool
}
var ErrInvalidPoolCap = errors.New("invalid pool cap")


const (
	RUNNING = 1
	STOPED = 0
)

func NewPool(capacity uint64) (*Pool, error) {
	if capacity <= 0 {
		return nil, ErrInvalidPoolCap
	}
	return &Pool{
		capacity: capacity,
		state:    RUNNING,
		// 初始化任务队列, 队列长度为容量
		taskC:    make(chan *Task, capacity),
		closeC:   make(chan bool),
	}, nil
}

func (p *Pool) run() {
	p.runningWorkers++ // 运行中的任务加一

	go func() {
		defer func() {
			p.runningWorkers-- // worker 结束, 运行中的任务减一
		}()

		for {
			select { // 阻塞等待任务、结束信号到来
			case task, ok := <-p.taskC: // 从 channel 中消费任务
				if !ok { // 如果 channel 被关闭, 结束 worker 运行
					return
				}
				// 执行任务
				task.Handler(task.Params...)
			case <-p.closeC: // 如果收到关闭信号, 结束 worker 运行
				return
			}
		}
	}()
}

func (p *Pool) Put(task *Task) {

	if p.runningWorkers < p.capacity { // 如果任务池满, 则不再创建 worker
		// 创建启动一个 worker
		p.run()
	}
	// 将任务推入队列, 等待消费
	p.taskC <- task
}

func main() {
	// 创建任务池
	pool, err := NewPool(10)
	if err != nil {
		panic(err)
	}

	for i := 0; i < 20; i++ {
		// 任务放入池中
		pool.Put(&Task{
			Handler: func(v ...interface{}) {
				fmt.Println(v)
			},
			Params: []interface{}{i},
		})
	}
	time.Sleep(time.Second) // 等待执行
}

```

