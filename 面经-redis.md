# redis

### redis过期策略和内存淘汰策略

​		redis是key-value型数据库，可以设置redis中缓存的key的过期时间，通常过期策略有三种

**定时过期**：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

**惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

**定期过期**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

​		Redis中同时使用了惰性过期和定期过期两种过期策略

### redis的内存淘汰策略

Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
- [allkeys-lru](https://www.zhihu.com/search?q=allkeys-lru&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"51024069"})：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
- [allkeys-random](https://www.zhihu.com/search?q=allkeys-random&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"51024069"})：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除**最近最少使用**的key。
- [volatile-random](https://www.zhihu.com/search?q=volatile-random&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"51024069"})：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

### ------------------------------

### redis存储结构

redis有五种基本数据类型，分别是 string，list，hash，set，zset，redis是key-value型数据库，key全部都是string类型

其余的是基于Redis的基本数据类型实现的

![preview](面经-redis.assets/v2-de9ab7871f5d06a76d9c376b32ac497e_r.jpg)

// Redis 的 **Set 是 String 类型的无序集合。**集合成员是唯一的，这就意味着集合中不能出现重复的数据,Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

//Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。

//zset是redis中一种有序、不重复的数据类型，每个元素都有一个分值，它可用于实现排行榜单，其底层采用压缩表ziplist或跳表skiplist的数据结构实现，首先创建时用ziplist，但ziplist需要存放在一段连续的内存空间上，当存储空间不足时会升级成skiplist。

//bitmap 可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmap中叫做偏移量，基于最小的单位bit进行存储，所以非常省空间。 2.设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，操作是非常快的。 3.二进制数据的存储，进行相关计算的时候非常快。 4.方便扩容

#### redis 存储对象信息是用string好还是hash好

具体使用哪种数据结构，其实是需要看你要存储的数据以及使用场景。

如果存储的都是比较结构化的数据，比如用户数据缓存，或者经常需要操作数据的一个或者几个，特别是如果一个数据中如果filed比较多，但是每次只需要使用其中的一个或者少数的几个，使用hash是一个好的选择，因为它提供了hget 和 hmget，而无需取出所有数据再在代码中处理。

反之，如果数据差异较大，操作时常常需要把所有数据都读取出来再处理，使用string 是一个好的选择。

#### ziplist 和 skiplist的比较

##### ziplist

ziplist实际上就可以理解为一个存放在连续内存空间上的双向列表，其每一个节点都包含了前置指针和后置指针，只是经过了特殊的编码步骤了的。连锁更新是ziplist的一大特点，为了节省内存，ziplist需要存放在一段连续的内存空间上，

##### skiplist

本质是解决查找问题，因为 zset 要支持随机的插入和删除，所以它 **不宜使用数组来实现**，为什么不使用红黑树、平衡树

1. **性能考虑：** 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 _(下面详细说)_；
2. **实现考虑：** 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观

*它不要求上下相邻两层链表之间的节点个数有严格的对应关系，**为每个节点随机出一个层数(level)**。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中

![preview](面经-redis.assets/v2-171b580cbdda1b2bce7b3087c1df682e_r.jpg)

### ------------------------------

### redis setnx分布式锁

​		在申请锁时，设置租期和唯一标识符（可以是自己的线程ID），在释放锁时，要先判断这把锁是否属于自己，属于自己再释放。判断+释放两步，要原子执行，借助Lua脚本。

` SET lock $uuid EX 20 NX` 

###### 锁过期时间不好评估怎么办？

​		**加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。**

### ------------------------------

### 为什么单线程的Redis可以支持高并发访问？

​		redis自身就是基于内存的数据库，因此数据处理速度非常快，另外它的底层使用了很多效率很高的数据结构，如哈希表和跳表等。这是它能支持高并发的原因之一；另一方面，redis使用的是IO多路复用技术，可以在网络操作中并发处理数十万的客户端连接访问。

​		每一个网络连接都是一个socket，都有对应的文件描述符，IO多路复用模块同时监听多个FD，当有事件产生时，文件事件处理器就回调FD绑定的事件处理器。虽然整个文件事件处理器是单线程上运行，但通过IO多路复用模块，实现了对多个FD读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。

#### redis多线程

​		随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈，Redis 的多线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。

## ------------------------------

### redis 主从同步

总的来说，主从同步有三种模式：

- 全量复制（第一次同步）
- 以及长连接的命令传播（正常工作状态下的常规同步）
- 增量复制

#### 全量复制如何实现的

​		master服务器会开启一个后台进程用于将redis中的数据**生成一个rdb文件**，与此同时，服务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该rdb文件传递给slave服务器，而**slave服务器会将rdb文件保存在磁盘并通过读取该文件将数据加载到内存**，在此之后master服务器会将在此期间缓存的命令通过redis传输协议发送给slave服务器，然后slave服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性。

#### 增量复制如何实现

​		master服务器内存中给每个slave服务器维护了一份**同步日志**和**同步标识**，每个slave服务器在跟master服务器进行同步时都会携带自己的同步标识和上次同步的最后位置。

​		当主从连接断掉之后，slave服务器隔断时间（默认1s）主动尝试和master服务器进行连接，如果从服务器携带的[偏移量](https://www.zhihu.com/search?q=偏移量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"2172285754"})标识还在master服务器上的**同步备份日志中**，那么就从slave发送的偏移量开始继续上次的同步操作，如果slave发送的偏移量已经不再master的同步备份日志中（可能由于主从之间断掉的时间比较长或者在断掉的短暂时间内master服务器接收到大量的写操作），则必须进行一次全量更新。在部分同步过程中，master会将本地记录的同步备份日志中记录的指令依次发送给slave服务器从而达到数据一致。