### 生产者消费者

1. 关闭一个未初始化(nil) 的 channel 会产生 panic
2. 重复关闭同一个 channel 会产生 panic
3. 向一个已关闭的 channel 中发送消息会产生 panic
4. 从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已读出，则会读到类型的零值。从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 的 ok-idiom，可以用它来判断 channel 是否关闭
5. 关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息

```go
package main

import (
	"fmt"
	"time"
)

func producer(ch chan<- int, closech chan struct{}) {
	for {
		select {
		case <-closech:
			close(ch)
		default:
			for i := 0; i < 10; i++ {
				ch <- i
				fmt.Printf("produce data %d \n", i)
			}
			time.Sleep(time.Millisecond * 500)
		}
	}
}

func consumer(ch <-chan int) {
	for data := range ch {
		fmt.Printf("got %d \n", data)
	}
}

func main() {
	ch := make(chan int, 10)
	closech := make(chan struct{})
	go producer(ch, closech)
	go consumer(ch)

	time.Sleep(time.Second)

}
```



```go
rtpackage main

import (
	"fmt"
	"math/rand"
	"strconv"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	producernum := 3
	consumer := 3
	maxmum :=100
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(consumer)

	dataCh := make(chan int, 100)
	stopCh := make(chan struct{})

	toStop := make(chan string,1)
	var stoppedBy string
	go func() {
		stoppedBy = <- toStop
		close(stopCh)
	}()
	for i := 0; i<producernum;i++{
		go func(i string) {
			for{
				value := rand.Intn(maxmum)
				if value == 0{
					select {
					case toStop <- "sender" + i:
					default:
					}
				}
				select {
				case <-stopCh:
					return
				case dataCh <-value:
				}

			}

		}(strconv.Itoa(i))
	}

	for i := 0; i<consumer; i++{
		go func(i string) {
			defer wgReceivers.Done()

			for{
				select {
				case <-stopCh:
					return
				case value := <-dataCh:
					if value == maxmum-1 {
						select {
						case toStop <- "receiver" + i:
						default:

						}
					}
					fmt.Println(value)
				}
			}

		}(strconv.Itoa(i))
	}

	wgReceivers.Wait()
	fmt.Println("stopped by", stoppedBy)
}

```

无缓冲通道channel必须在接受方与发送方同时准备好时，通道才能正常传递数据，否则双方只有一方在线都会阻塞。

缓冲通道当缓冲区满时，发送数据会阻塞，当缓冲区空时，接受数据会阻塞。发送方与接收方不需要同时做好准备。		

### -----------------------------

### 交替打印ABC

```go
package main

import (
	"fmt"
	"time"
)

var chanA chan struct{}
var chanB chan struct{}
var chanC chan struct{}
func main() {
	chanA = make(chan struct{})
	chanB = make(chan struct{})
	chanC = make(chan struct{})

	go sendA()
	go sendB()
	go sendC()
	chanA <- struct{}{}
	time.Sleep(time.Second)
}

func sendA(){
	for{
		select {
		case <- chanA :
			fmt.Println("A")
			time.Sleep(time.Millisecond*100)
			chanB <- struct{}{}
		default:
		}
	}
}

func sendB(){
	for{
		select {
		case <- chanB :
			fmt.Println("B")
			time.Sleep(time.Millisecond*100)
			chanC <- struct{}{}
		default:
		}
	}
}

func sendC(){
	for{
		select {
		case <- chanC :
			fmt.Println("C")
			time.Sleep(time.Millisecond*100)
			chanA <- struct{}{}
		default:
		}
	}
}

```

### -----------------------------

### go 实现协程池

```go
package main

import (
	"errors"
	"fmt"
	"time"
)

type Task struct {
	TaskIndex int
}

type Pool struct {
	capacity         int
	runningWorkerNum int
	state            int
	TaskC            chan *Task
	closeChan        chan bool
}

// 创建线程池
var errNews = errors.New("invalid pool")

const (
	running = 0
	stop    = 1
)

// 创建线程池
func newPool(capacity int) (*Pool, error) {
	if capacity < 0 {
		return nil, errNews
	}
	return &Pool{
		capacity:         capacity,
		runningWorkerNum: 0,
		state:            1,
		TaskC:            make(chan *Task, capacity),
		closeChan:        make(chan bool),
	}, nil
}

// 放入任务
func (p *Pool) Put(task *Task) {
	if p.runningWorkerNum < p.capacity {
		p.Run()
	}
	p.TaskC <- task
}

func (p *Pool) Run() {
	p.runningWorkerNum++

	go func() {
		defer func() {
			p.runningWorkerNum--
		}()
		for {
			select {
			case <-p.TaskC:
				time.Sleep(time.Millisecond)
				fmt.Println("任务执行")
			case <-p.closeChan:
				fmt.Println("关闭通道")
				return
			}
		}
	}()
}

func main() {
	pool, err := newPool(10)
	if err != nil {
		fmt.Println(err)
	}

	for i := 0; i < 2000; i++ {
		task := &Task{i}
		fmt.Printf("task %d has put \n", task.TaskIndex)
		pool.Put(task)
	}
	time.Sleep(time.Second)
}


```







```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

var T, length int

func main() {
	fmt.Scan(&T)
	sc := bufio.NewScanner(os.Stdin)
	bs := make([]byte, 2000*1024)
	sc.Buffer(bs, len(bs))
	for T > 0 {
		// 处理好输入
		sc.Scan()
		length, _ = strconv.Atoi(sc.Text())
		//fmt.Println(length)

		xy := make([][2]int, length)
		sc.Scan()
		l := strings.Split(sc.Text(), " ")
		for i, s := range l {
			temp, _ := strconv.Atoi(s)
			xy[i][0] = temp
		}

		sc.Scan()
		l = strings.Split(sc.Text(), " ")
		for i, s := range l {
			temp, _ := strconv.Atoi(s)
			xy[i][1] = temp
		}

		//fmt.Println(xy)
		// 开始处理逻辑
		res := 0

		for i := 0; i < length; i++ {
			tempres := 0
			for j := 0; j < length; j++ {
				if i == j {
					continue
				} else {
					// fmt.Println(i, j)
					if ((xy[i][1] < xy[j][1]) && (xy[i][0] < xy[j][0])) || ((xy[i][1] > xy[j][1]) && (xy[i][0] > xy[j][0])) {
						tempres++
					}
				}

			}
			res = max(res, tempres)
		}
		fmt.Println(res)
		T--
	}
}

func max(i, j int) int {
	if i > j {
		return i
	} else {
		return j
	}
}

```

