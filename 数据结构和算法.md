#### ke递归三步

###### 1.递归函数的确定

递归函数&&递归参数&&返回值

确定那些参数是递归过程中需要处理的，就在递归函数里加上这个参数，并且明确每次递归的返回值是什么进而确定递归函数的返回类型

###### 2.确定终止条件

递归务必要中止，否则会内存栈溢出

###### 3.确定单层递归的逻辑

确定每层递归需要处理的信息，在这里就会重复强调自己实现递归的过程

##### 二叉树前序遍历

迭代： 栈，从后面进，先进右叶子，再进左叶子





构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。

#### 回溯

可以借助一些标志元素，回溯前后修改好

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



#### 动态规划

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 红黑树和AVL（平衡二叉搜索树）数

普通二叉搜索树在极端情况下会退化称链表

同样节点数下红黑树的高度>= AVL数

**红黑树弱平衡**，最长路径小于最短路径长的两倍；AVL是强平衡，最多差1

**为保证强平衡**，AVL树因此插入、删除开销大，但是查找性能更好；

### 快排思想

​		快排的思想也比较简单，对于一个数据长度大于1的数组，随机找出其中一个元素来作为[基准元素](https://www.zhihu.com/search?q=基准元素&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"39789468"})，然后再遍历一遍该数组，同时将每个元素与基准元素进行比较，如果某元素的值大于基准元素则把该元素放在基准元素的右边，反之如果某元素的值小于基准元素则把该元素放在基准元素的左边，这样遍历一遍下来基准元素左边的元素都小于基准元素，基准元素右边的元素都大于基准元素。接下来再依次把基准元素左右两边的元素按照上面同样的步骤做同样的处理，最终得到的就是一个有序数组。

### 解决哈希冲突的办法

链地址法：比较简单，冲突不厉害的时候可以用

### LRU最近最久未使用

### LFU最少使用
