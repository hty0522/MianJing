#### ke递归三步

###### 1.递归函数的确定

递归函数&&递归参数&&返回值

确定那些参数是递归过程中需要处理的，就在递归函数里加上这个参数，并且明确每次递归的返回值是什么进而确定递归函数的返回类型

###### 2.确定终止条件

递归务必要中止，否则会内存栈溢出

###### 3.确定单层递归的逻辑

确定每层递归需要处理的信息，在这里就会重复强调自己实现递归的过程

##### 二叉树前序遍历

迭代： 栈，从后面进，先进右叶子，再进左叶子





构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。

#### 回溯

可以借助一些标志元素，回溯前后修改好

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



#### 动态规划

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 红黑树和AVL（平衡二叉搜索树）数

普通二叉搜索树在极端情况下会退化称链表

同样节点数下红黑树的高度>= AVL数

**红黑树弱平衡**，最长路径小于最短路径长的两倍；AVL是强平衡，最多差1

**为保证强平衡**，AVL树因此插入、删除开销大，但是查找性能更好；

### 排序算法

#### 快排

​		快排的思想也比较简单，对于一个数据长度大于1的数组，随机找出其中一个元素来作为[基准元素](https://www.zhihu.com/search?q=基准元素&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"39789468"})，然后再遍历一遍该数组，同时将每个元素与基准元素进行比较，如果某元素的值大于基准元素则把该元素放在基准元素的右边，反之如果某元素的值小于基准元素则把该元素放在基准元素的左边，这样遍历一遍下来基准元素左边的元素都小于基准元素，基准元素右边的元素都大于基准元素。接下来再依次把基准元素左右两边的元素按照上面同样的步骤做同样的处理，最终得到的就是一个有序数组。

​		的平均时间复杂度为O(NlogN)。最坏情况下O(N2) 

#### 冒泡排序

​		依次比较相邻的两个元素，如果顺序错误就交换，重复进行直到排序完成。

​		冒泡排序最好的[时间复杂度](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)为 O(n)（已经排好，遍历一次），最坏正好反向排序O(N2)

#### 选择排序

​		选择排序(Selection sort)是一种简单直观的排序算法。其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

​		选择排序的时间复杂度是O(N2)

#### 归并排序

1. 将n个元素从中间切开，分成两部分。（左边可能比右边多1个数）
2. 将步骤1分成的两部分，再分别进行[递归分解](https://www.zhihu.com/search?q=递归分解&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"36075856"})。直到所有部分的元素个数都为1。
3. 从最底层开始逐步合并两个排好序的数列。

归并排序的时间复杂度为O(nlogn)

#### 插入排序

​		**把数组分成已排序和未排序两个区间，以数组第一个元素当做已排序区间，剩下的即被当做未排序区间，每次都从未排序区间中找出一个元素来和已排序区间中的元素比较，并插入到已排序区间中的合适位置，直到未排序区间元素为 0** 

​		[平均时间复杂度](https://www.zhihu.com/search?q=平均时间复杂度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"122293204"})：O(N^2)

#### 希尔排序

​		也是基于插入排序的思想，通过分组的方式，各组之间先进行插入排序，然后增加每组元素数再进行排序，直至变成一组，等同于直接排序。低于时间复杂度为O(N^2)

#### 堆排序

​		堆数据结构是一种数组对象，可以被视为一棵完全二叉树，树中每个节点与数组中存放该节点值的元素对应。树的每一层是满的，最后一层除外（最后一层从一个节点的左子树开始填）

1. 首先对数组进行建堆，这样得到最大堆
2. 取堆的根节点，也就是最大值
3. 保持树的结构不变，将根节点与最后一个值交换，然后对根节点进行MAX-HEAPIFY，这样第二大的值就成为根节点，因此类推

堆排序运行时间为 O(nlogn)，快于插入排序

### 解决哈希冲突的办法

链地址法：比较简单，冲突不厉害的时候可以用

### LRU最近最久未使用

### LFU最少使用
